"""Animated bouncing ball demo using the raytracer"""

import __spy__
import os
from _list import List
from _range import range
from math import tan, fabs
from time import sleep, time
from raytracer import Vec3, Ray, Color, Sphere, Plane, Object, trace_ray
from raytracer import vec3_normalize

BENCHMARK = False


def render_frame(width: i32, height: i32, ball_pos: Vec3) -> None:
    # Scene setup
    objects = List[Object]()

    # Bouncing red ball
    sphere1 = Sphere(ball_pos, 0.8, Color(1.0, 0.3, 0.3))
    objects.append(Object(0, sphere1, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))

    # Static blue sphere
    sphere2 = Sphere(Vec3(2.5, -0.3, -6.0), 1.0, Color(0.3, 0.3, 1.0))
    objects.append(Object(0, sphere2, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))

    # Ground plane
    plane1 = Plane(Vec3(0.0, -1.5, 0.0), vec3_normalize(Vec3(0.0, 1.0, 0.0)), Color(0.7, 0.7, 0.7))
    objects.append(Object(1, Sphere(Vec3(0.0, 0.0, 0.0), 0.0, Color(0.0, 0.0, 0.0)), plane1))

    light_dir = vec3_normalize(Vec3(0.5, 1.0, 0.3))
    camera_pos = Vec3(0.0, 0.0, 0.0)

    aspect_ratio = float(width) / float(height)
    fov = 3.14159265358979323846 / 3.0

    for y in range(height):
        line = ''
        for x in range(width):
            # Calculate ray direction
            px = (2.0 * (float(x) + 0.5) / float(width) - 1.0) * aspect_ratio * tan(fov / 2.0)
            py = (1.0 - 2.0 * (float(y) + 0.5) / float(height)) * tan(fov / 2.0)

            direction = vec3_normalize(Vec3(px, py, -1.0))
            ray = Ray(camera_pos, direction)

            # Trace ray
            color = trace_ray(ray, objects, light_dir)

            # Convert to 8-bit color
            r_int = int(color.r * 255.0)
            g_int = int(color.g * 255.0)
            b_int = int(color.b * 255.0)

            if r_int > 255:
                r_int = 255
            if g_int > 255:
                g_int = 255
            if b_int > 255:
                b_int = 255

            # Use ANSI 24-bit color escape code to set background color
            line += '\033[48;2;' + str(r_int) + ';' + str(g_int) + ';' + str(b_int) + 'm '

        # Reset color at end of line and print
        line += '\033[0m'
        print(line)


def animate() -> None:
    term_size = os.get_terminal_size()
    width = term_size.columns
    height = term_size.lines - 2

    if __spy__.is_compiled() == False:
        # interp mode is super slow, use a smaller size
        width = 30
        height = 10

    # Physics parameters
    gravity = 9.8

    # Ball initial position (up-left)
    x0 = -2.0
    y0 = 2.0
    z0 = -4.0

    # Initial velocity
    vx = 1.5
    vy = 0.0
    vz = 0.0

    # Current position and velocity
    x = x0
    y = y0
    z = z0

    # Bounce parameters
    ground_y = -1.5 + 0.8
    damping = 0.7

    # FPS tracking
    frame_count = 0
    fps_update_interval = 10
    last_fps_time = time()
    fps = 0.0

    if BENCHMARK == False:
        # Enter alternate screen buffer
        print('\033[?1049h')
        # Hide cursor
        print('\033[?25l')

    last_frame_time = time()
    max_frames = 300

    while frame_count < max_frames:
        # Measure actual frame time
        current_time = time()
        dt = current_time - last_frame_time
        last_frame_time = current_time

        # Update physics
        vy = vy - gravity * dt
        y = y + vy * dt
        x = x + vx * dt
        z = z + vz * dt

        # Check for ground collision
        if y <= ground_y:
            y = ground_y
            vy = -vy * damping

            # Stop bouncing if velocity is too small
            if fabs(vy) < 0.3:
                vy = 0.0

        # Render current frame
        ball_pos = Vec3(x, y, z)

        if BENCHMARK == False:
            # Move cursor to home
            print('\033[H')
            render_frame(width, height, ball_pos)
        else:
            # In benchmark mode, still trace rays but don't render to screen
            objects = List[Object]()
            sphere1 = Sphere(ball_pos, 0.8, Color(1.0, 0.3, 0.3))
            objects.append(Object(0, sphere1, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))
            sphere2 = Sphere(Vec3(2.5, -0.3, -6.0), 1.0, Color(0.3, 0.3, 1.0))
            objects.append(Object(0, sphere2, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))
            plane1 = Plane(Vec3(0.0, -1.5, 0.0), vec3_normalize(Vec3(0.0, 1.0, 0.0)), Color(0.7, 0.7, 0.7))
            objects.append(Object(1, Sphere(Vec3(0.0, 0.0, 0.0), 0.0, Color(0.0, 0.0, 0.0)), plane1))

            light_dir = vec3_normalize(Vec3(0.5, 1.0, 0.3))
            camera_pos = Vec3(0.0, 0.0, 0.0)
            aspect_ratio = float(width) / float(height)
            fov = 3.14159265358979323846 / 3.0

            for py in range(height):
                for px in range(width):
                    px_norm = (2.0 * (float(px) + 0.5) / float(width) - 1.0) * aspect_ratio * tan(fov / 2.0)
                    py_norm = (1.0 - 2.0 * (float(py) + 0.5) / float(height)) * tan(fov / 2.0)
                    direction = vec3_normalize(Vec3(px_norm, py_norm, -1.0))
                    ray = Ray(camera_pos, direction)
                    trace_ray(ray, objects, light_dir)

        # Update FPS counter
        frame_count = frame_count + 1
        if frame_count % fps_update_interval == 0:
            elapsed = current_time - last_fps_time
            fps = float(fps_update_interval) / elapsed
            last_fps_time = current_time

            if BENCHMARK:
                print('Frame: ' + str(frame_count) + ' | FPS: ' + str(int(fps)))

        if BENCHMARK == False:
            # Display info
            print('FPS: ' + str(int(fps)) + ' | Frame: ' + str(frame_count))

        # Reset if ball goes too far right
        if x > 5.0:
            x = x0
            y = y0
            z = z0
            vx = 1.5
            vy = 0.0
            vz = 0.0

    if BENCHMARK == False:
        # Show cursor
        print('\033[?25h')
        # Exit alternate screen buffer
        print('\033[?1049l')

    print('Animation stopped.')
    print('Final FPS: ' + str(int(fps)) + ' | Total frames: ' + str(frame_count))

def main() -> None:
    animate()
