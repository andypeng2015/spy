"""Simple ASCII raytracer with ANSI color support"""

import os
from _list import List
from _range import range
from math import sqrt, tan, fabs

@struct
class Vec3:
    x: float
    y: float
    z: float

def vec3_add(self: Vec3, other: Vec3) -> Vec3:
    return Vec3(self.x + other.x, self.y + other.y, self.z + other.z)

def vec3_sub(self: Vec3, other: Vec3) -> Vec3:
    return Vec3(self.x - other.x, self.y - other.y, self.z - other.z)

def vec3_mul(self: Vec3, scalar: float) -> Vec3:
    return Vec3(self.x * scalar, self.y * scalar, self.z * scalar)

def vec3_dot(self: Vec3, other: Vec3) -> float:
    return self.x * other.x + self.y * other.y + self.z * other.z

def vec3_length(self: Vec3) -> float:
    return sqrt(vec3_dot(self, self))

def vec3_normalize(self: Vec3) -> Vec3:
    l = vec3_length(self)
    return Vec3(self.x / l, self.y / l, self.z / l)


@struct
class Ray:
    origin: Vec3
    direction: Vec3


@struct
class Color:
    r: float
    g: float
    b: float


@struct
class HitRecord:
    point: Vec3
    normal: Vec3
    t: float
    color: Color


@struct
class Sphere:
    center: Vec3
    radius: float
    color: Color


def sphere_intersect(sphere: Sphere, ray: Ray) -> HitRecord:
    oc = vec3_sub(ray.origin, sphere.center)
    a = vec3_dot(ray.direction, ray.direction)
    b = 2.0 * vec3_dot(oc, ray.direction)
    c = vec3_dot(oc, oc) - sphere.radius * sphere.radius
    discriminant = b * b - 4.0 * a * c

    if discriminant < 0.0:
        # Return sentinel with negative t
        return HitRecord(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0, 0.0), -1.0, Color(0.0, 0.0, 0.0))

    t = (-b - sqrt(discriminant)) / (2.0 * a)
    if t < 0.001:
        return HitRecord(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0, 0.0), -1.0, Color(0.0, 0.0, 0.0))

    point = vec3_add(ray.origin, vec3_mul(ray.direction, t))
    normal = vec3_normalize(vec3_sub(point, sphere.center))
    return HitRecord(point, normal, t, sphere.color)


@struct
class Plane:
    point: Vec3
    normal: Vec3
    color: Color


def plane_intersect(plane: Plane, ray: Ray) -> HitRecord:
    denom = vec3_dot(plane.normal, ray.direction)
    if fabs(denom) < 0.0001:
        return HitRecord(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0, 0.0), -1.0, Color(0.0, 0.0, 0.0))

    t = vec3_dot(vec3_sub(plane.point, ray.origin), plane.normal) / denom
    if t < 0.001:
        return HitRecord(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0, 0.0), -1.0, Color(0.0, 0.0, 0.0))

    point = vec3_add(ray.origin, vec3_mul(ray.direction, t))

    # Checkerboard pattern
    color = plane.color
    checker_size = 2.0
    xi = int(point.x / checker_size)
    zi = int(point.z / checker_size)
    if (xi + zi) % 2 == 0:
        color = Color(0.9, 0.9, 0.9)

    return HitRecord(point, plane.normal, t, color)


@struct
class Object:
    # 0 = sphere, 1 = plane
    obj_type: i32
    sphere: Sphere
    plane: Plane


def object_intersect(obj: Object, ray: Ray) -> HitRecord:
    if obj.obj_type == 0:
        return sphere_intersect(obj.sphere, ray)
    else:
        return plane_intersect(obj.plane, ray)


def trace_ray(ray: Ray, objects: List[Object], light_dir: Vec3) -> Color:
    closest_t = 1e30  # Using large float instead of inf
    has_hit = False
    closest_hit = HitRecord(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0, 0.0), -1.0, Color(0.0, 0.0, 0.0))

    for i in range(len(objects)):
        hit = object_intersect(objects[i], ray)
        if hit.t >= 0.0:
            if hit.t < closest_t:
                closest_hit = hit
                closest_t = hit.t
                has_hit = True

    if has_hit == False:
        # Sky gradient
        t = 0.5 * (ray.direction.y + 1.0)
        return Color(0.5 + 0.5*t, 0.7 + 0.3*t, 1.0)

    # Simple diffuse lighting
    light_intensity = vec3_dot(closest_hit.normal, light_dir)
    if light_intensity < 0.0:
        light_intensity = 0.0

    # Ambient + diffuse
    ambient = 0.2
    total_intensity = ambient + (1.0 - ambient) * light_intensity

    # Apply color
    r = closest_hit.color.r * total_intensity
    g = closest_hit.color.g * total_intensity
    b = closest_hit.color.b * total_intensity

    return Color(r, g, b)


def render(width: i32, height: i32) -> None:
    # Scene setup
    objects = List[Object]()

    # Red sphere
    sphere1 = Sphere(Vec3(0.0, 0.0, -5.0), 1.5, Color(1.0, 0.3, 0.3))
    objects.append(Object(0, sphere1, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))

    # Green sphere
    sphere2 = Sphere(Vec3(-2.0, -0.5, -4.0), 0.8, Color(0.3, 1.0, 0.3))
    objects.append(Object(0, sphere2, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))

    # Blue sphere
    sphere3 = Sphere(Vec3(2.5, -0.3, -6.0), 1.0, Color(0.3, 0.3, 1.0))
    objects.append(Object(0, sphere3, Plane(Vec3(0.0, 0.0, 0.0), Vec3(0.0, 1.0, 0.0), Color(0.0, 0.0, 0.0))))

    # Ground plane
    plane1 = Plane(Vec3(0.0, -1.5, 0.0), vec3_normalize(Vec3(0.0, 1.0, 0.0)), Color(0.7, 0.7, 0.7))
    objects.append(Object(1, Sphere(Vec3(0.0, 0.0, 0.0), 0.0, Color(0.0, 0.0, 0.0)), plane1))

    light_dir = vec3_normalize(Vec3(0.5, 1.0, 0.3))
    camera_pos = Vec3(0.0, 0.0, 0.0)

    aspect_ratio = float(width) / float(height)
    fov = 3.14159265358979323846 / 3.0  # pi / 3

    for y in range(height):
        line = ''
        for x in range(width):
            # Calculate ray direction
            px = (2.0 * (float(x) + 0.5) / float(width) - 1.0) * aspect_ratio * tan(fov / 2.0)
            py = (1.0 - 2.0 * (float(y) + 0.5) / float(height)) * tan(fov / 2.0)

            direction = vec3_normalize(Vec3(px, py, -1.0))
            ray = Ray(camera_pos, direction)

            # Trace ray
            color = trace_ray(ray, objects, light_dir)

            # Convert to 8-bit color
            r_int = int(color.r * 255.0)
            g_int = int(color.g * 255.0)
            b_int = int(color.b * 255.0)

            if r_int > 255:
                r_int = 255
            if g_int > 255:
                g_int = 255
            if b_int > 255:
                b_int = 255

            # Use ANSI 24-bit color escape code to set background color
            line += '\033[48;2;' + str(r_int) + ';' + str(g_int) + ';' + str(b_int) + 'm '

        # Reset color at end of line and print
        line += '\033[0m'
        print(line)


def main() -> None:
    size = os.get_terminal_size()
    render(size.columns, size.lines)
    #render(120, 40)
    #render(60, 20)
